using System;
using Lynx.Core.PeerVerification.Interfaces;
using System.Threading.Tasks;
using Lynx.Core.Communications.Interfaces;
using Lynx.Core.Communications.Packets;
using Lynx.Core.Communications.Packets.Interfaces;
using Lynx.Core.Crypto;
using Lynx.Core.Crypto.Interfaces;
using Lynx.Core.Interfaces;
using Lynx.Core.Models.IDSubsystem;
using Lynx.Core.Communications;
using Lynx.Core.Facade.Interfaces;
using Attribute = Lynx.Core.Models.IDSubsystem.Attribute;

namespace Lynx.Core.PeerVerification
{
    public class ScanningPeer : Peer, IScanningPeer
    {
		private ITokenCryptoService<IInfoRequestToken> _tokenCryptoService;
		private ID _id;
		private IAccountService _accountService;
		private ISession _session;
		private IIDFacade _idFacade;

        public ScanningPeer(ITokenCryptoService<IInfoRequestToken> tokenCryptoService, IAccountService accountService, ID id, IIDFacade idFacade) : base(tokenCryptoService, accountService, idFacade)
        {
            _tokenCryptoService = tokenCryptoService;
			_id = id;
			_accountService = accountService;
			_idFacade = idFacade;
			_session = new PubNubSession(new EventHandler<string>(async (sender, e) => await ProcessEncryptedHandshakeToken<SynAck>(e)));
		}

		public async Task ProcessSyn(string infoRequestSynString)
		{
            InfoRequestTokenFactory<InfoRequestSyn> synFactory = new InfoRequestTokenFactory<InfoRequestSyn>(_idFacade);
			InfoRequestSyn syn = (InfoRequestSyn)synFactory.CreateInfoRequestTokenAsync(infoRequestSynString);

			byte[] pubK = Nethereum.Hex.HexConvertors.Extensions.HexByteConvertorExtensions.HexToByteArray(syn.PublicKey);

            VerifyInfoRequestTokenIDOwnership(syn);

			if (_tokenCryptoService.VerifySignature(syn))
				Acknowledge(syn);
			else
				throw new SignatureDoesntMatchException("The signature was not " +
														"generated by the given " +
														"public Key");
		}

		/// <summary>
		/// Creates and transmits an ACK in response to a previously processed SYN
		/// </summary>
		private void Acknowledge(IInfoRequestSyn syn)
		{
            InfoRequestAck ack = new InfoRequestAck()
			{
				Id = _id,
				PublicKey = _accountService.PublicKey,
				Encrypted = true
			};

			byte[] requesterPubKey = Nethereum.Hex.HexConvertors.Extensions.HexByteConvertorExtensions.HexToByteArray(syn.PublicKey);
			string encryptedToken = _tokenCryptoService.Encrypt(ack, requesterPubKey, _accountService.GetPrivateKeyAsByteArray());
			_session.Open(syn.NetworkAddress);
			_session.Send(encryptedToken);
		}

        protected override InfoRequestToken ProcessEncryptedInfoRequestToken<T>(string encryptedInfoRequestToken)
		{
			InfoRequestSynAck synAck = (InfoRequestSynAck)base.ProcessEncryptedInfoRequestToken<InfoRequestSynAck>(encryptedInfoRequestToken);
			GenerateAndSendResponse(synAck);
            return synAck;
		}

		/// <summary>
		/// JSON-Encodes and sends attributes and attribute contents to the verifier for certification
		/// </summary>
		private void GenerateAndSendResponse(InfoRequestSynAck infoRequestSynAck)
		{
            string[] requestedAttributesDescription = infoRequestSynAck.RequestedAttributes;
            Attribute[] requestedAttributes = new Attribute[requestedAttributesDescription.Length];
			for (int i = 0; i < requestedAttributesDescription.Length; i++)
			{
				requestedAttributes[i] = _id.Attributes[requestedAttributesDescription[i]];
			}

            InfoRequestResponse response = new InfoRequestResponse()
			{
				Id = _id,
				PublicKey = _accountService.PublicKey,
				Encrypted = true
			};
            response.RequestedAttributes = requestedAttributes; 

			byte[] requesterPubKey = Nethereum.Hex.HexConvertors.Extensions.HexByteConvertorExtensions.HexToByteArray(infoRequestSynAck.PublicKey);
			string encryptedToken = _tokenCryptoService.Encrypt(response, requesterPubKey, _accountService.GetPrivateKeyAsByteArray());
			_session.Send(encryptedToken);
		}

    }
}
