using System;
using System.Text;
using Lynx.Core.Communications.Interfaces;
using Lynx.Core.Communications.Packets;
using Lynx.Core.Communications.Packets.Interfaces;
using Lynx.Core.Crypto;
using Lynx.Core.Crypto.Interfaces;
using Lynx.Core.Interfaces;
using Lynx.Core.Models.IDSubsystem;
using Lynx.Core.PeerVerification.Interfaces;
using Attribute = Lynx.Core.Models.IDSubsystem.Attribute;
using Lynx.Core.Facade;
using System.Threading.Tasks;
using Lynx.Core.Models.IDSubsystem;


namespace Lynx.Core.PeerVerification
{
    public class Verifier : IVerifier
    {
        private ITokenCryptoService<IHandshakeToken> _tokenCryptoService;
        private ID _id;
        private IAccountService _accountService;
        private ISession _session;
        private IDFacade _iDFacade;

        public Verifier(ITokenCryptoService<IHandshakeToken> tokenCryptoService, IAccountService accountService, ID id, IDFacade iDFacade)
        {
            _tokenCryptoService = tokenCryptoService;
            _id = id;
            _accountService = accountService;
            _iDFacade = iDFacade;
        }

        public ISyn Syn { get; set; }

        public void Acknowledge()
        {
            Attribute[] accessibleAttributes = { _id.Attributes["firstname"], _id.Attributes["lastname"] };

            Ack ack = new Ack()
            {
                Id = _id,
                PublicKey = _accountService.PublicKey,
                Encrypted = true,
                AccessibleAttributes = accessibleAttributes
            };

            byte[] requesterPubKey = Encoding.UTF8.GetBytes(Syn.PublicKey);
            string encryptedToken = _tokenCryptoService.Encrypt(ack, requesterPubKey, _accountService.GetPrivateKeyAsByteArray());
            _session.Send(encryptedToken);
        }

        public async Task<ISyn> ProcessSyn(string synString)
        {
            HandshakeTokenFactory<Syn> synFactory = new HandshakeTokenFactory<Syn>(_iDFacade);
            Syn syn = await synFactory.CreateHandshakeTokenAsync(synString);
            if (_tokenCryptoService.Verify(syn, Encoding.UTF8.GetBytes(syn.PublicKey)))
                return syn;
            else
                throw new SignatureDoesntMatchException("The signature was not " +
                                                        "generated by the given " +
                                                        "public Key");
        }
    }
}
