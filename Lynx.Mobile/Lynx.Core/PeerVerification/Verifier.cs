using System;
using System.Text;
using Lynx.Core.Communications.Packets;
using Lynx.Core.Communications.Packets.Interfaces;
using Lynx.Core.Crypto;
using Lynx.Core.Crypto.Interfaces;
using Lynx.Core.PeerVerification.Interfaces;
using Lynx.Core.Facade;
using System.Threading.Tasks;
using Lynx.Core.Models.IDSubsystem;


namespace Lynx.Core.PeerVerification
{
    public class Verifier : IVerifier
    {
        private ITokenCryptoService<IHandshakeToken> _tokenCryptoService;
        private IDFacade _idFacade;

        public Verifier(ITokenCryptoService<IHandshakeToken> tokenCryptoService, IDFacade idFacade)
        {
            _tokenCryptoService = tokenCryptoService;
            _idFacade = idFacade;
        }

        public ISyn Syn { get; set; }

        public void Acknowledge(string privateKey, string publicKey)
        {
            throw new NotImplementedException();
        }

        public async void ProcessSyn(string synString)
        {
            TokenFactory<Syn> synFactory= new TokenFactory<Syn>(_idFacade);
            string[] accessibleAttributes = new string[]{""};//dummy temporary array 
            Syn syn = await synFactory.CreateToken(synString, accessibleAttributes);
			string pubAddress = AccountService.GeneratePublicAddressFromPublicKey(syn.PublicKey);
			if (!_tokenCryptoService.Verify(syn, Encoding.UTF8.GetBytes(syn.PublicKey)))
				throw new SignatureDoesntMatchException("The signature was not " +
														"generated by the given " +
														"public Key");
            if (pubAddress != syn.ID.Owner)
				throw new AddressDoesntMatchException("The address was not " +
														"generated by the given " +
														"public Key");
			
            Acknowledge(null, null);
        }
    }
}
