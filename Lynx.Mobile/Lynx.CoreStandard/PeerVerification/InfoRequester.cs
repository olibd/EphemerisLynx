using System;
using System.Threading.Tasks;
using Lynx.Core.Communications;
using Lynx.Core.Communications.Interfaces;
using Lynx.Core.Communications.Packets;
using Lynx.Core.Communications.Packets.Interfaces;
using Lynx.Core.Crypto;
using Lynx.Core.Crypto.Interfaces;
using Lynx.Core.Facade.Interfaces;
using Lynx.Core.Interfaces;
using Lynx.Core.Models.IDSubsystem;
using Attribute = Lynx.Core.Models.IDSubsystem.Attribute;

namespace Lynx.Core.PeerVerification
{
    public class InfoRequester : Requester
    {
		private ISession _session;
		private ID _id;
		private ITokenCryptoService<IToken> _tokenCryptoService;
		private IAccountService _accountService;
		private Attribute[] _accessibleAttributes;
        private string[] _requestedAttributes;
        private IIDFacade _idFacade;
        public event EventHandler<HandshakeCompleteEvent> handshakeComplete;

        public InfoRequester(string[] requestedAttributes, ITokenCryptoService<IToken> tokenCryptoService, IAccountService accountService, ID id, IIDFacade idFacade, IAttributeFacade attributeFacade, ICertificateFacade certificateFacade) : base(tokenCryptoService, accountService, id, idFacade, attributeFacade, certificateFacade)
        {
			_tokenCryptoService = tokenCryptoService;
			_accountService = accountService;
            _idFacade = idFacade;
			_session = new PubNubSession(new EventHandler<string>(async (sender, e) => await ProcessEncryptedHandshakeToken<Ack>(e)));
			_id = id;
			_accessibleAttributes = new Attribute[]{
				_id.Attributes["firstname"],
				_id.Attributes["lastname"],
				_id.Attributes["cell"],
				_id.Attributes["address"]
			};
            _requestedAttributes = requestedAttributes;
        }

		protected override async Task<T> ProcessEncryptedHandshakeToken<T>(string encryptedHandshakeToken)
		{
			string[] tokenArr = encryptedHandshakeToken.Split(':');

			switch (tokenArr[0])
			{
				case "ack":
					await ProcessAck(encryptedHandshakeToken);
					break;

				case "inforeqresp":
                    await ProcessInfoRequestResponse(encryptedHandshakeToken);
					break;

				default:
					throw new InvalidTokenTypeException("The Token type received is invalid");
			}

			//We can return null because the caller of this method is an anonymous method in an EventHandler
			//and it won't use the returned data
			return null;
		}

		private async Task ProcessAck(string encryptedToken)
		{
			Ack ack = await ProcessToken<Ack>(encryptedToken);

			VerifyHandshakeTokenIDOwnership(ack);

			if (_tokenCryptoService.VerifySignature(ack))
			{
				Ack = ack;
				GenerateAndSendInfoRequestSynAck(ack);
			}
			else
				throw new SignatureDoesntMatchException("The signature was not " +
														"generated by the given " +
														"public Key");
		}

		private void GenerateAndSendInfoRequestSynAck(Ack ack)
		{
			InfoRequestSynAck infoRequestSynAck = new InfoRequestSynAck()
			{
				Id = _id,
				PublicKey = _accountService.PublicKey,
				Encrypted = true,
				AccessibleAttributes = _accessibleAttributes,
				RequestedAttributes = _requestedAttributes
			};

			byte[] requesterPubKey = Nethereum.Hex.HexConvertors.Extensions.HexByteConvertorExtensions.HexToByteArray(ack.PublicKey);
			_tokenCryptoService.Sign(infoRequestSynAck, _accountService.GetPrivateKeyAsByteArray());
			string encryptedToken = _tokenCryptoService.Encrypt(infoRequestSynAck, requesterPubKey, _accountService.GetPrivateKeyAsByteArray());
			_session.Send(encryptedToken);
		}

		private async Task ProcessInfoRequestResponse(string encryptedToken)
		{
            InfoRequestResponse infoRequestResponse = await ProcessToken<InfoRequestResponse>(encryptedToken);
            VerifyHandshakeTokenIDOwnership(infoRequestResponse);

            HandshakeCompleteEvent e;
			if (_tokenCryptoService.VerifySignature(infoRequestResponse))
            {
				e = new HandshakeCompleteEvent()
				{
                    Id = infoRequestResponse.Id,
				};
				handshakeComplete.Invoke(this, e);
            }
            else
				throw new SignatureDoesntMatchException("The signature was not " +
														"generated by the given " +
														"public Key");
		}

		private async Task<T> ProcessToken<T>(string encryptedHandshakeToken) where T : HandshakeToken, new()
		{
			string decryptedToken = _tokenCryptoService.Decrypt(encryptedHandshakeToken, _accountService.GetPrivateKeyAsByteArray());
			HandshakeTokenFactory<T> handshakeTokenFactory = new HandshakeTokenFactory<T>(_idFacade);
			T handshakeToken = await handshakeTokenFactory.CreateHandshakeTokenAsync(decryptedToken);

			return handshakeToken;
		}
    }
}
