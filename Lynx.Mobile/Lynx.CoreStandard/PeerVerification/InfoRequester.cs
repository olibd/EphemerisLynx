using System;
using System.Threading.Tasks;
using Lynx.Core.Communications.Packets;
using Lynx.Core.Communications.Packets.Interfaces;
using Lynx.Core.Crypto;
using Lynx.Core.Crypto.Interfaces;
using Lynx.Core.Facade.Interfaces;
using Lynx.Core.Interfaces;
using Lynx.Core.Models.IDSubsystem;
using Attribute = Lynx.Core.Models.IDSubsystem.Attribute;

namespace Lynx.Core.PeerVerification
{
    public class InfoRequester : Requester
    {
        private ID _id;
        private Attribute[] _accessibleAttributes;
        private string[] _requestedAttributes;
        public event EventHandler<HandshakeCompleteEvent> handshakeComplete;

        public InfoRequester(string[] requestedAttributes, ITokenCryptoService<IToken> tokenCryptoService, IAccountService accountService, ID id, IIDFacade idFacade, IAttributeFacade attributeFacade, ICertificateFacade certificateFacade) : base(tokenCryptoService, accountService, id, idFacade, attributeFacade, certificateFacade)
        {
            _id = id;
            _accessibleAttributes = new Attribute[]{
                _id.Attributes["firstname"],
                _id.Attributes["lastname"],
                _id.Attributes["cell"],
                _id.Attributes["address"]
            };
            _requestedAttributes = requestedAttributes;
        }

        protected override async Task RouteEncryptedHandshakeToken<T>(string encryptedHandshakeToken, ID id = null)
        {
            string[] tokenArr = encryptedHandshakeToken.Split(':');

            switch (tokenArr[0])
            {
                case "ack":
                    await ProcessAck(encryptedHandshakeToken);
                    break;

                case "inforeqresp":
                    await ProcessInfoRequestResponse(encryptedHandshakeToken);
                    break;

                default:
                    throw new InvalidTokenTypeException("The Token type received is invalid");
            }
        }

        protected override void GenerateAndSendSynAck(Ack ack)
        {
            InfoRequestSynAck infoRequestSynAck = new InfoRequestSynAck()
            {
                Id = _id,
                PublicKey = _accountService.PublicKey,
                Encrypted = true,
                AccessibleAttributes = _accessibleAttributes,
                RequestedAttributes = _requestedAttributes
            };

            byte[] requesterPubKey = Nethereum.Hex.HexConvertors.Extensions.HexByteConvertorExtensions.HexToByteArray(ack.PublicKey);
            _tokenCryptoService.Sign(infoRequestSynAck, _accountService.GetPrivateKeyAsByteArray());
            string encryptedToken = _tokenCryptoService.Encrypt(infoRequestSynAck, requesterPubKey, _accountService.GetPrivateKeyAsByteArray());
            _session.Send(encryptedToken);
        }

        private async Task ProcessInfoRequestResponse(string encryptedToken)
        {
            InfoRequestResponse infoRequestResponse = await DecryptAndInstantiateHandshakeToken<InfoRequestResponse>(encryptedToken);
            VerifyHandshakeTokenIDOwnership(infoRequestResponse);

            HandshakeCompleteEvent e;
            if (_tokenCryptoService.VerifySignature(infoRequestResponse))
            {
                e = new HandshakeCompleteEvent()
                {
                    Id = infoRequestResponse.Id,
                };
                handshakeComplete.Invoke(this, e);
            }
            else
                throw new SignatureDoesntMatchException("The signature was not " +
                                                        "generated by the given " +
                                                        "public Key");
        }
    }
}
